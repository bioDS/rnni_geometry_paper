\documentclass[11pt]{amsart}


\usepackage[ibidtracker=false,uniquename=false,giveninits=true,terseinits=true,backend=biber]{biblatex}
\usepackage{float}
\usepackage{graphicx}
\usepackage{todonotes}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage[foot]{amsaddr}
\usepackage[misc]{ifsym}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage[hidelinks]{hyperref}

\renewbibmacro{in:}{}
\addbibresource{rnni_geometry.bib}
\AtEveryBibitem{
	\clearlist{language}
}

\setlist{leftmargin = 0pt}
\geometry{margin=1in}


\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{problem}{Problem}
\newtheorem{conjecture}{Conjecture}

\newcommand{\lemmaautorefname}{Lemma}
\newcommand{\corollaryautorefname}{Corollary}
\renewcommand{\sectionautorefname}{Section}

\newcommand{\tocite}{ {\color{red}\fbox{CITATION}} }
\newcommand{\toref}{ {\color{blue}\fbox{Reference}} }
\newcommand{\rnni}{\mathrm{RNNI}}
\newcommand{\findpath}{\textsc{FindPath}}
\newcommand{\mrca}{\mathrm{mrca}}
\newcommand{\rank}{\mathrm{rank}}
\newcommand{\ntime}{\mathrm{time}}
\newcommand{\nni}{\mathrm{NNI}}
\newcommand{\spr}{\mathrm{SPR}}
\newcommand{\tbr}{\mathrm{TBR}}
\newcommand{\fp}{\mathrm{FP}}
\newcommand{\dtt}{\mathrm{DtT}}
\newcommand{\np}{\mathbf{NP}}
\newcommand{\decprob}[1]{\rnni(#1)\text{-}\mathrm{SP}}
\newcommand{\rad}{\mathit{rad}}
\renewcommand{\O}{\mathcal O}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\thesubfigure}{\Alph{subfigure}}

\newcommand{\algorithmautorefname}{Algorithm}

\newcommand{\summary}[1]{\textbf{#1}} % Print summaries to .pdf
% \newcommand{\summary}[1]{} % Hide summaries in .pdf

\newcommand{\todefine}[1]{{\color{blue}{We need to define:#1}}} % Print summaries to .pdf

\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}

\graphicspath{{figures/}}

\sloppy


\title[Geometry of ranked tree spaces]{The Geometry of the Ranked Nearest Neighbour Interchange Space}
\date{\today}
\author{Lena Collienne}
\email{lcollienne@cs.otago.ac.nz}
\address{Department of Computer Science, University of Otago, New Zealand}
\author{Alex Gavryushkin\textsuperscript{\Letter}}
\email{\textsuperscript{\Letter}alex@biods.org}
\thanks{}

\begin{document}

\begin{abstract}
\end{abstract}

\maketitle


\section{Introduction}

\todo{Include Alex's idea from github issue \#1}
\summary{Why we want time-trees}

\summary{Why discrete time-trees -- Summarising for example}

\summary{How recent results about $\rnni$ make this space interesting and that it is strongly connected to $\dtt_m$}

\summary{Why we want to investigate geometrical properties of $\dtt_m$ and $\rnni$, and also $\rnni(\rho)$}

\summary{Structure of the paper.}


\section{Technical Introduction}

\summary{Introducing discrete time-trees and ranked trees}
A binary rooted phylogenetic tree is a binary tree on a fixed number $n$ of leaves, which are uniquely labelled by elements of the set $\{a_1, \ldots, a_n\}$.
The main objective of study in this paper, \emph{discrete time-trees}, are such binary rooted phylogenetic trees, where nodes are assigned \emph{times}, which are positive integers.
More specifically, all leaves are assigned time $0$, and every internal nodes is assigned a unique time, such that it always has time greater than its children.
We denote the time of an internal node $v$ by $\ntime(v)$.
If not stated otherwise, we refer to discrete time-trees simply as \emph{trees}.
We furthermore call two trees 
\todo{We need 'identical' for non-binary trees in the definition of the $\nni$ move. Is this confusing here or can we keep it like this?}
(not necessarily binary) \emph{identical} if there is a graph isomorphism between them preserving leaf labels and times.
The number of discrete time-trees with root time less or equal to $m$ is $\frac{(n-1)!n!m^{n-1}}{2^{n-1}}$ \autocite{Gavryushkin2018-ol}.

As special case of discrete time-trees are \emph{ranked trees} where the root has time $n-1$.
Then internal nodes are uniquely labelled by times in $\{1, \ldots, n-1\}$, and hence this definition of ranked trees coincides with the one of \textcite{Collienne2020-iu}.
In the case of ranked trees we say \emph{rank} of a node $v$ to mean its time ($\rank(v) = \ntime(v)$) to be consistent with notations used in \autocite{Collienne2020-iu}.

Every internal node $v$ of a tree $T$ can be referred to by the set $C$ of leaves that are descending from this node.
We call such a set $C$ \emph{cluster} and say that the cluster $C$ is \emph{induced} by $v$.
A list of clusters $[C_1, \ldots, C_{n-1}]$ uniquely defines a ranked tree, where cluster $C_i$ is induced by the internal node with rank $i$ for $i \in \{1, \ldots, n-1\}$.
For each subset $S \subseteq \{a_1, \ldots, a_n\}$ we call the internal node of a tree $T$ with lowest time that is ancestral to all elements of $S$ the \emph{most recent common ancestor} of $S$ and denote it by $(S)_T$.
\todo{Do we need the definition of $(T)_i$? It currently only appears in the FP pseudo-code}
We denote the parent of a leaf $a_i$ in $T$ by $(a_i)_T$, and the cluster induced by the node with time $i$ in $T$ by $(T)_i$.

\summary{Defining the tree space $\dtt_m$ and $\rnni = \dtt_{n-1}$}
We are now ready to introduce the centre of study in this paper, the graph (or space) of discrete time-trees.
This graph is called $\dtt_m$ for a fixed positive integer $m$.
The vertex set of $\dtt_m$ is the set of trees with root time less or equal to $m$.
Trees $T$ and $R$ are connected by an edge in this graph if performing one of the following (reversible) operations on $T$ results in $R$:
\begin{enumerate}
	\item An \emph{$\nni$ move} connects trees $T$ and $R$ if there is an edge $e$ in $T$ and an edge $f$ in $R$, both of length one, such that shrinking $e$ and $f$ to nodes results in identical trees.
	\item A \emph{rank move} on $T$ exchanges the times of two internal nodes with time difference one.
	\item A \emph{length move} on $T$ changes the time of an internal node by one.
\end{enumerate}
A length move can only change the time of a node to become $t$ if there is no node with time $t$ already.
Note that our definition of $\dtt_m$ differs from the definition of \textcite{Gavryushkin2018-ol}, as length move are defined differently in their paper.

The definition of $\dtt_m$ leads to a natural definition of the \emph{distance} between two trees $T$ and $R$ in this graph as the length of a shortest paths between these trees, denoted by $d(T,R)$.
We also consider the ranked nearest neighbour interchange ($\rnni$) graph of \textcite{Collienne2020-iu}, which is the graph $\dtt_m$ for $m=n-1$, and hence a graph of ranked trees.
In this graph length moves are not possible, so we use the notion $\rnni$ \emph{move} to mean either a rank move or an $\nni$ move to distinguish these moves from length moves.

\todefine{
	\begin{itemize}
		\item 'neighbour' ?
		\item We need to mention that $m$ is fixed when we compute distances between two trees
		\item $\rnni(\rho)$ -- in corresponding section
		\item intervals -- only needed in $\rnni(\rho)$ section (e.g. for Lemma~\ref{lemma:nni_path_to_caterpillar})
		\item $(T)_i$ for cluster induced by node of rank $i$ in $T$ -- this is only needed for proofs around $\rnni(\rho)$ and in the proof that every tree is connected to a caterpillar tree in $\rnni$ by a sequence of $\nni$ moves AND $\findpath$ pseudo-code (!)
		\item We sometimes say $\rnni$ instead of $\rnni$ space. If we keep that, we might want to mention that we do it? -- We use just '$\rnni$' in polynomial paper as well!
		\item distinguish the shortest path problem from the distance problem! -- maybe mention that $\findpath$ is optimal algorithm for shortest path problem
	\end{itemize}
}


\section{Computing Shortest Paths in $\dtt_m$}
\label{section:fp_dtt}

\summary{Introduce how we can use $\findpath$ to compute $\dtt_m$ distances}
Distances between trees in $\rnni$ can be computed in quadratic running time with the algorithm $\findpath$, introduced by \textcite{Collienne2020-iu}.
As $\rnni$ is a special case of $\dtt_m$ for $m = n-1$, the question whether this algorithm can also be used to compute distances in $\dtt_m$ arises.
In this section we present a generalisation of $\findpath$ that computes distances between trees in $\dtt_m$.
Before introducing the version of $\findpath$ for $\dtt_m$, we introduce a way to convert trees in $\dtt_m$ into ranked trees, such that the $\rnni$ distance between those ranked trees equals their distance in $\dtt_m$ (\autoref{thm:dtt_findpath}).

\summary{How to add leaves to a $\dtt_m$ tree to transform it into a ranked tree}
Therefore, we consider trees $T$ and $R$ and construct ranked trees $T_r$ and $R_r$ as follows.
Let $m$ be the maximum root time of $T$ and $R$.
To receive a ranked tree $T_r$ on $m+2$ leaves from $T$, we add leaves to $T$ as follows (\autoref{alg:ranked_tree}).
The same is done for $R$ to get a ranked tree $R_r$.
To construct $T_r$, consider the tree $T$ and add a new root with time $m + 1$ that becomes parent of the root of $T$.
\todo{Define caterpillar tree (in technical intro?!)}
The second child of this new root is the root of a caterpillar tree on leaf set $\{a_{n+1}, a_{n+2}, \ldots, a_{m+2}\}$, such that $\ntime(a_{n+1}) = \ntime(a_{n+2}) < \ntime(a_{n+3}) < \ldots < \ntime(a_{m+2})$.
Hence $T_r$ is a uniquely defined ranked tree with $m+2$ leaves.
An example of this extension of a tree $T$ to a ranked tree $T_r$ is depicted in \autoref{fig:dtt_to_ranked_tree}.

\begin{algorithm}[ht]
	\caption{RankedTree($T$)}
	\label{alg:ranked_tree}
	\begin{algorithmic}[1]
		\STATE $S:= \{1 \leq i \leq m | \text{ no internal node in } T \text{ has time } i\}$
		\STATE $[i_1, \ldots, i_{m-n+1}] = sort(S)$
		\STATE $T_r := T$ with additional internal node $v_1$ with children $a_{n+1}, a_{n+2}$ and time $i_1$
		\FOR {$k = 2, \dots, m-n+1$}
			\STATE Add internal node $v_k$ with with children $v_{k-1}$ and $a_{n+k+1}$ and time $i_k$ to $T_r$
		\STATE add internal node $\rho$ with children $v_{m-n}$ and $(\{a_1, \ldots, a_n\})_{T_r}$ to $T_r$
		\ENDFOR
		\RETURN $T_r$
	\end{algorithmic}
\end{algorithm}

\begin{figure}[ht]
	\includegraphics[width=0.75\textwidth]{dtt_to_ranked_tree.eps}
	\caption{Extending a tree $T$ on $n$ leaves in $\dtt_6$ (left) to a ranked tree with $m+2=8$ leaves (right) by adding a caterpillar subtree with three leaves.}
	\label{fig:dtt_to_ranked_tree}
\end{figure}

\summary{How to compute shortest $\dtt_m$-paths between trees with $\findpath$}
\todo{Add an example to make relation of length move and rank move clear}
After extending both trees $T$ and $R$ to ranked trees $T_r$ and $R_r$ on $m+2$ leaves, respectively, we can compute shortest paths between $T_r$ and $R_r$ in $\rnni$, using $\findpath$.
A path computed by $\findpath$ preserves clusters \autocite{Collienne2020-iu}, hence there are no $\nni$ moves in the newly added caterpillar tree with leaves in $\{a_{n+1}, \ldots, a_{m+2}\}$ on such a path.
The only moves involving internal nodes of this caterpillar subtree are rank moves.
Each of these rank moves can be seen as a length move, if only considering the changes such a move does to the (discrete time-) subtree induced by $\{a_1, \ldots, a_n\}$.
Hence the path $\fp(T_r,R_r)$ provides a path between $T$ and $R$ in $\dtt_m$, when only considering the subtrees induced by $\{a_1, \ldots, a_n\}$ in all trees on $\fp(T_r, R_r)$.
We denote this path in $\dtt_m$, which results from $\fp(T_r, R_r)$, by $\fp(T,R)$.
In \autoref{thm:dtt_findpath} we establish that $\fp(T,R)$ is a shortest path in $\dtt_m$ indeed.
Note that for any given pair of trees $T$ and $R$ we always assume $m$ to be the maximum root time of these trees in and aim to compute a shortest path between them in $\dtt_m$. 

\begin{theorem}
	The path $\fp(T,R)$ between two discrete time-trees $T$ and $R$ is a shortest path in $\dtt_m$, where $m$ is the maximum root time of $T$ and $R$.
	\label{thm:dtt_findpath}
\end{theorem}

\begin{proof}
	Let $T$ and $R$ be discrete time-trees and $T_r$ and $R_r$ their extended ranked versions computed with \autoref{alg:ranked_tree}, respectively.
	We have already seen above that, if interpreting some rank moves on the extended ranked versions of trees as length moves, a path computed by $\findpath$ can be seen as a path between discrete time-trees.
	It is also possible to convert a path between discrete time-trees to a path between their extended ranked versions by replacing length moves with rank moves, analogous to how it is described above, while all other moves stay the same.
	Therefore, any path in $\dtt_m$ from $T$ to $R$ gives a path of equal length between $T_r$ and $R_r$ in the $\rnni$ space on $m+2$ leaves.
	If there was a path between $T$ and $R$ shorter than $\fp(T,R)$, the corresponding path between $T_r$ and $R_r$ in $\rnni$ would be shorter than the one computed by $\findpath$ in this space.
	Since this contradicts \autocite[Theorem 1]{Collienne2020-iu}, it follows that $\fp(T,R)$ is a shortest path in $\dtt_m$.
\end{proof}

\summary{Running time of $\findpath$ + we don't need to add subtree in practice}
\autoref{thm:dtt_findpath} shows that $\findpath$ (\autoref{alg:fp_dtt}) computes shortest path between two trees in $\dtt_m$ in polynomial time, more specifically in $\O(mn)$, more details on this are provided following \autoref{thm:dtt_diameter}.
It is not even necessary to convert a given pair of discrete time-trees to ranked trees to apply $\findpath$ on them.
Instead, we can define a modified version of $\findpath$ for trees in $\dtt_m$.
Therefore, iterations of $\findpath$ on the ranked trees that consider clusters in the added caterpillar trees are replaced by length moves increasing the time of internal nodes as described in the \textbf{for} loop in Line~\ref{line:length_move} of \autoref{alg:fp_dtt}.
The benefit of this modified version of the algorithm, compared to using $\findpath$ on the extended ranked versions of the trees, is a reduced use of memory, which is especially of practical relevance for $m >> n$.

Throughout this paper we will however consider $\findpath$ applied to the extended ranked versions of discrete time-trees, as this simplifies some proofs.

\begin{algorithm}[h]
	\caption{$\findpath$($T,R$)}
	\begin{algorithmic}[1]
		\label{alg:fp_dtt}
		\STATE $T_1 := T$, $p := [T_1]$
		\FOR {$k = 1, \dots, m$}
			\IF {$R$ has a node with rank $i$}
			\STATE $C:=(R)_i$
			\WHILE {$\rank((C)_{T_1})>k$}
					\STATE $T_2$ is $T_1$ with the rank of $(C)_{T_1}$ decreased by an $\rnni$ move
				\STATE $T_1 = T_2$
				\STATE $p = p+T_1$
			\ENDWHILE
			\ELSE
				\STATE $i := \min\{l | l>k \text{ and no node in} T_1 \text{ has time }l\}$
				\FOR {$j = i-1, \dots, k$}
					\label{line:length_move}
					\STATE $T_2$ is $T_1$ where the time of $(T_1)_j$ is increased by one (length move)
					\STATE $T_1 = T_2$
					\STATE $p = p+T_1$
				\ENDFOR
			\ENDIF
		\ENDFOR
		\RETURN $p$
	\end{algorithmic}
\end{algorithm}


\section{Geometrical Properties of $\dtt_m$}

\subsection{Cluster Property}
\summary{Definition of Cluster Property and why it is relevant (a bit of bio).}
In this section we consider a property of tree spaces that is of relevance because of its biological meaning and its connection to complexity results in a tree space similar to $\rnni$.
We say that a tree space has the \emph{cluster property}, if all trees on every shortest paths between two trees sharing a cluster $C$ also contain this cluster.
This is desirable biological property as for example for a given sample of trees containing a common subtree, it is expected a summary or mean tree of the sample also contains this subtree.

\summary{Cluster property in $\nni$ and its connection to the complexity result.}
A tree space very similar to $\rnni$, that has been studied extensively \tocite is the $\nni$ graph on trees without times where $\nni$ moves are allowed on every edge.
Computing distances in $\nni$ is $\np$-hard\autocite{Dasgupta2000-xa}, and the proof relies on the fact that this tree space does not have the cluster property \autocite{Li1996-zw}.
In the $\rnni$ graph, however, distances can be computed in polynomial time by the algorithm $\findpath$ \autocite{Collienne2020-iu}, which preserves common clusters.
The question whether $\rnni$ has the cluster property is hence natural, and will be settled in \autoref{thm:cluster_property_rnni}.
\todo{Does $\spr$ have the cluster property?}
Note that even though it seems like distances can be computed in polynomial time in a tree space if it has the cluster property, this does not need to be true in general.

\summary{$\rnni$ has the cluster property.}
\begin{theorem}
	The $\rnni$ graph has the cluster property.
	\label{thm:cluster_property_rnni}
\end{theorem}

\begin{proof}
	We assume to the contrary that there are two ranked trees sharing a cluster that are connected by a shortest path that does not preserve this cluster.
	Let $T$ and $R$ be ranked trees with minimal distance among those, with shared cluster $C$ that is not present in every tree on a shortest path $p$ between $T$ and $R$.
	Because of this minimality assumption on the length of $p$, the first tree $T'$ after $T$ on $p$ does not contain $C$.
	Therefore, all nodes with rank below $(C)_T$ induce the same clusters in $T$ and $T'$.
	We now compare the distances $d(T,R)$ and $d(T',R)$ by comparing paths $\findpath$ computes between $T$ and $R$ with those computed between $T'$ and $R$.

	All trees on $\fp(R,T)$ and $\fp(R, T')$ coincide until the point is reached where the cluster that is considered by $\findpath$ on $R$ and $T$ is $C$.
	Let $\hat T$ denote the tree right before cluster $C$ is considered.
	Then $\fp(R,T)$ and $\fp(R,T')$ coincide up to this tree $\hat T$.
	It follows $d(T,R) = d(R,\hat T) + d(\hat T, T)$ and $d(T',R) = d(R,\hat T) + d(\hat T, T')$.

	Now consider $\fp(T', \hat T)$, which has length $d(\hat T, T')$.
	As $\findpath$ preserves clusters, $C$ is present in every tree on $\fp(T,R)$ up to and including $\hat T$.
	The fist iteration of $\findpath$ applied to the pair of trees $(T',\hat T)$ considers the cluster $C$, as all cluster induced by nodes below $(C)_{T'}$ coincide in $\hat T$ and $T'$.
	\todo{Do we need a figure here?}
	To construct the cluster $C$ in $T'$, there is just one $\nni$ move needed, which results in the tree $T$, as $T$ and $T'$ are $\nni$ neighbours such that $T$ contains $C$ and $T'$ does not.
	We can therefore conclude that $d(T,R) = d(T',R) - 1$, which contradicts the assumption that $T'$ is the first tree on a shortest path from $T$ to $R$.
	Hence, there is no shortest path between $T$ and $R$ that does not preserve $C$ which shows that the $\rnni$ graph has the cluster property.
\end{proof}

The fact that a slightly modified version of $\findpath$ computes shortest paths $\dtt_m$ already suggest that there is a close relation between shortest path in $\rnni$ and $\dtt_m$.
With the following lemma we see that any shortest path in $\dtt_m$ provides a shortest path in $\rnni$.
In the remainder of the paper, this lemma will be an essential tool for generalising geometrical properties of $\rnni$ to $\dtt_m$.

\begin{lemma}
	The distance between two trees $T$ and $R$ in $\dtt_m$ is the sum of the minimum number of $\rnni$ moves and the minimum number of length moves on any shortest path between these trees.
	\label{lemma:dtt_path_sum}
\end{lemma}

\begin{proof}
	Let $T$ and $R$ be trees in $\dtt_m$.
	We prove the lemma by showing that $\findpath$ minimises both the number of length moves and the number of $\rnni$ moves.
	As $\fp(T,R)$ is a shortest path (\autoref{thm:dtt_findpath}), it follows that all shortest paths have this property.
	Let $T_r$ and $R_r$ be the extended ranked versions of $T$ and $R$, respectively, computed with \autoref{alg:ranked_tree}.

	The caterpillar subtrees $T_c$ and $R_c$ on the leaf subset $\{a_{n+1}, \ldots, a_{m+2}\}$ that are added to $T$ and $R$ by \autoref{alg:ranked_tree}, respectively, contain the same clusters.
	Since clusters are preserved on shortest paths in $\rnni$ (\autoref{thm:cluster_property_rnni}), the only moves on any shortest path between $T_r$ and $R_r$ that effect internal nodes of the added caterpillar trees are rank moves.
	Therefore, the minimum number of moves needed to transform $T_c$ to $R_c$ on any path is $\sum_{i = n+1}^{m+2} |\rank(a_{i})_{T_c} - \rank(a_{i})_{R_c}|$, which is the number rank of moves that $\findpath$ takes for these subtrees.

	To prove that the number of $\rnni$ moves on $\fp(T,R)$ is minimal as well, we assume to the contrary that there is a path $p$ between $T$ and $R$ in $\dtt_m$ with less $\rnni$ moves.
	This path provides a path in $\rnni$ between ranked trees $\hat T$ and $\hat R$, which result from $T$ and $R$ by ignoring times of internal nodes and only keeping their ranks, with length $|p| < \fp(\hat T, \hat R)$, contradicting that $\findpath$ computes shortest paths in $\rnni$.

	It follows that $\findpath$ computes a shortest paths minimising both the number of $\rnni$ moves and the number of length moves in $\dtt_m$ and hence every shortest path in this space has this property.
\end{proof}

With \autoref{lemma:dtt_path_sum} the cluster property in $\dtt_m$ follows from \autoref{thm:cluster_property_rnni}.

\begin{corollary}
	The graph $\dtt_m$ has the cluster property.
\end{corollary}

\subsection{Caterpillar Trees}

\summary{Defining Caterpillar trees. Why are they interesting?}
In this subsection we focus on \emph{caterpillar trees}, that are trees where each internal node has at least one child that is a leaf.
If a path between two caterpillar trees only consists of caterpillar trees, we call this path a \emph{caterpillar path}.
In \autoref{thm:caterpillar_convex_rnni} and \autoref{cor:caterpillar_convex_dtt} we will see that, in both $\rnni$ and $\dtt_m$, any two caterpillar trees are connected by a shortest path that is a caterpillar path.
For a set of trees for which there is a shortest path that stays within this set we say that the set is \emph{convex} in the corresponding tree space.
This is another property of $\rnni$ that the $\nni$ space of unranked trees does not have \autocite{Gavryushkin2018-ol}.
Based on the convexity of the set of caterpillar trees in $\rnni$ we introduce a way to compute distances between caterpillar trees in this space in time $\O(n\log n)$ \autoref{cor:caterpillar_distance_rnni_nlogn}, and hence better worst-time complexity than $\findpath$.

\begin{theorem}
	The set of caterpillar trees is convex in $\rnni$.
	\label{thm:caterpillar_convex_rnni}
\end{theorem}

\begin{proof}
	Let $T$ and $R$ be two caterpillar trees in $\rnni$.
	We prove the theorem by showing that there is a tree that is neighbour of $T$ and closer to $R$ than $T$.
	The existence of a caterpillar path that is a shortest path between $T$ and $R$ follows inductively.

	We consider the leaf $a_k := \argmax_{a_1, \ldots, a_n}\{\rank(a_i)_R | \rank(a_i)_R \neq \rank(a_i)_T\}$ to be the leaf with parent with maximum rank in $R$ among those that are not in the same position in $T$ and $R$.
	Let $T'$ be the caterpillar tree resulting from $T$ by performing an $\nni$ move exchanging leaves $a_k$ and $a_j$, where $\rank(a_j)_T = \rank(a_k)_T + 1$.
	By using properties of shortest paths computed by $\findpath$, we now show that $|\fp(R,T')| = |\fp(R,T)| - 1$, proving the theorem.

	Since all clusters of $T$ and $T'$ induced by nodes of rank less than $\rank(a_k)_T$ coincide, the paths $\fp(T,R)$ and $\fp(T',R)$ coincide up to a tree $R'$, which contains all these clusters.
	\todo{Is this obvious?}
	Moreover, it is $\rank(a_k)_{R'}  > \rank(a_j)_{R'}$, as this relation does not change on the path computed by $\findpath$ between $R$ and $R'$.
	Let $S$ be the largest cluster that is shared between $R', T,$ and $T'$ (see \autoref{fig:proof_caterpillar_convex_rnni}).

	\begin{figure}[ht]
		\includegraphics[width=0.66\textwidth]{proof_caterpillar_convex_rnni.eps}
		\caption{Trees $T$, $T'$, and $R'$ as described in the proof of \autoref{thm:caterpillar_convex_rnni}.
		All three trees share the subtree induced by subset $S$ of leaves.
		Between $T$ and $T'$ only leaves $a_j$ and $a_k$ are exchanged.
		Dashed lines represent remaining part of trees, which are equal in $T$ and $T'$.}
		\label{fig:proof_caterpillar_convex_rnni}
	\end{figure}

	We now compare the lengths of $\fp(R',T)$ and $\fp(R',T')$.
	By our assumptions on $T$, the clusters considered on $\fp(R,T)$ in the two iterations following $R'$ are $S \cup \{a_k\}$ and $S \cup \{a_k, a_j\}$.
	Decreasing the rank of $(S \cup \{a_k\})_{R'}$ takes $\rank(S \cup \{a_k\})_{R'} - (\rank(S)_{R'} + 1)$ $\rnni$ moves, the following iteration for $S \cup \{a_k, a_j\}$ takes $\rank(S \cup \{a_j\})_{R'} + 1 - (\rank(S)_{R'} + 2)$.
	In particular, the rank of the most recent common ancestor of $S \cup \{a_k, a_j\}$ equals the rank of the most recent common ancestor of $S \cup \{a_j\}$ after the first iteration following $R'$, as $a_j$ has parent with rank higher than $a_k$ at that point.
	Since the parents of $a_k$ and $a_j$ exchange while the rank of $(S \cup \{a_k\})_{R'}$ decreases, the rank of $(S \cup \{a_j\}$ decreases by one during that iteration, compared to $R'$.
	On $\fp(R,T')$ first $\rank(S \cup \{a_j\})_{R'} - (\rank(S)_{R'} + 1)$ $\rnni$ moves decrease the rank of $(S \cup \{a_j\})_{R'}$, and then $\rank(S \cup \{a_j, a_k\})_{R'} - (\rank(S)_{R'} + 2)$ are needed for $S \cup \{a_k, a_j\}$.

	Let $Q$ and $Q'$ be the trees on $\fp(R,T)$ and $\fp(R,T')$, respectively, after the two iterations following $R'$.
	By the above the number of moves on $\fp(R,T)$ between $R'$ and $Q$ is one higher than the number of moves on $\fp(R,T')$ between $R'$ and $Q'$.
	Since the trees $Q'$ and $T'$ can be received from permuting the leaves of $Q$ and $T$ by the same permutation, namely the transposition $(a_j, a_k)$, the distances between these pairs of trees coincide: $d(Q,T) = d(Q',T')$.
	We can conclude $d(R,T) = d(R,T') + 1$, and hence $T'$ is on a shortest path from $T$ to $R$.
\end{proof}

\begin{corollary}
	The set of caterpillar trees is convex in $\dtt_m$.
	\label{cor:caterpillar_convex_dtt}
\end{corollary}

\begin{proof}
	With \autoref{lemma:dtt_path_sum} it is sufficient to show that there is a caterpillar path between two caterpillar trees $T$ and $R$ that minimises the number of $\rnni$ moves needed on any path between these two trees.
	This however follows immediately from the convexity of the set of caterpillar trees in $\rnni$ (\autoref{thm:caterpillar_convex_rnni}), which proves this corollary.
\end{proof}

\summary{With Theorem~\ref{thm:caterpillar_convex_rnni} we can find a more efficient way to compute distances between caterpillar trees.}
Using the convexity of the set of caterpillar trees (\autoref{thm:caterpillar_convex_rnni}), we can find several new ways of computing the distance between two caterpillar trees.

\todo{Do I need to go more into detail about TSP?}
A problem analogous to the problem of computing distances between caterpillar trees is the \emph{Token Swapping Problem} (TSP) \autocite{Kawahara2017-ey} on a special class of graphs, the so-called lollipop graphs.
The only moves possible between caterpillar trees are $\nni$ moves, which simply swap two leaves, can be translated to swapping two tokens in TSP.
\textcite{Kawahara2017-ey} provide an algorithm for TSP on lollipop graphs, which can be used for computing distances between caterpillar trees in $\rnni$ as well.
This algorithm however has worst-case time complexity $\O(n^2)$, the same as $\findpath$.

We see in \autoref{thm:caterpillar_distance_formula} that there is a formula to express distances between two caterpillar trees in $\rnni$, which decreases the worst-case running time for computing distances between caterpillar trees to $\O(n \log n)$ (\autoref{cor:caterpillar_distance_rnni_nlogn}).
Using the results for caterpillar trees in $\rnni$, distances between caterpillar trees in $\dtt_m$ can be computed in $\O(m + n \log n)$ in $\dtt_m$ (\autoref{cor:caterpillar_distance_dtt_m_nlogn}).

\begin{theorem}
	Let $T$ and $R$ be caterpillar trees in $\rnni$ such that \[1 = \rank(a_1)_R = \rank(a_2)_r < \rank(a_3)_R < \ldots < \rank(a_n)_R = n-1.\]
	Then it is
	\[d(T,R) = p_T - m_T,\]
	where $p_T$ is the number of transpositions in $T$ (Kendall-tau distance between $T$ and $R$) and $m_T = |M_T|$ for
	\begin{align*}
		M_T := &\{a_i| (\forall k \textnormal{ with } \rank(a_k)_T \leq \rank(a_i)_T: \rank(a_k)_R > \rank(a_i)_r)\} \\
		& \cap \{a_i | \rank(a_i)_T < \min\{\rank(a_1)_T, \rank(a_2)_T\}\}
	\end{align*}
	\label{thm:caterpillar_distance_formula}
\end{theorem}

\begin{proof}
	Let $\hat d(T,R) = p_T - m_T$, so we need to prove $\hat d(T,R) = d(T,R)$ for trees $T$ and $R$ as described above.
	It is sufficient to prove that for any caterpillar tree $T'$ with distance one to $T$ it is
	\begin{align}
		\hat d(T',R) \geq \hat d(T,R) - 1.
		\label{eq:distance_proof}
	\end{align}
	With this it follows by induction that $\hat d$ and $d$ coincide, using the \autoref{thm:caterpillar_convex_rnni}, the existence of a shortest path consisting only of caterpillar trees.

	To prove the correctness of Inequality~\ref{eq:distance_proof}, we first prove $p_{T'} \geq p_T - 1$ and then $m_{T'} \leq m_t + 1$.
	Then the only case in which Inequality~\ref{eq:distance_proof} does not hold is $p_{T'} = p_T - 1$ and $m_{T'} = m_t + 1$, which we will show to be impossible.

	As the only move possible between caterpillar trees $T$ and $T'$ is an $\nni$ move exchanging two leaves, at most one transposition of $T$ can be resolved in $T'$, resulting in $p_{T'} \geq p_T - 1$.
	Let $a_k, a_j$ be the labels of leaves that exchange their position between $T$ and $T'$, such that $\rank(a_k)_T < \rank(a_j)_T$.
	Since these are the only leaves that change positions between $T$ and $T'$, they are the only elements that could be in $M_{T'} \setminus M_T$.
	It remains to show $(M_{T'} \setminus M_T) \neq \{a_k, a_j\}$, from which we can follow $m_{T'} \leq m_T - 1$.

	We prove this by showing that if $a_k \notin M_T$, it follows either $a_k \notin M_{T'}$, or $a_j \notin M_{T'}$.
	If $a_k \notin M_T$, at least one of the following conditions must be violated for $i = k$:
	% Set counter for equation to get C1 and C2 for conditions
	\setcounter{equation}{0}
	\renewcommand{\theequation}{C\arabic{equation}}
	\begin{align}
		\forall l \text{ with } \rank(a_l)_T \leq \rank(a_i)_T: \rank(a_l)_R > \rank(a_i)_R \label{condition1}\\
		\rank(a_i)_T < \min\{\rank(a_1)_T, \rank(a_2)_T\}.
		\label{condition2}
	\end{align}
	% reset counter for future uses
	\setcounter{equation}{1}
	\renewcommand{\theequation}{\arabic{equation}}

	At first we consider the case that for $a_k$ Condition~\ref{condition1} is violated in $T$.
	It follows that there is a $l$ such that $\rank(a_l)_T < rank(a_k)_T$ and $\rank(a_k)_R > \rank(a_l)_R$.
	It immediately follows that the same condition is violated for $a_k$ in $T'$, because the $\nni$ move exchanging $a_k$ and $a_j$ preserves the relationship of $a_k$ and $a_l$.
	Therefore, it is $a_k \notin M_{T'}$.

	Let us now assume that Condition~\ref{condition2} is violated for $a_k$ to not be in $M_T$.
	It follows $\rank(a_k)_T \geq \min\{\rank(a_1)_T, \rank(a_2)_T\}$.
	As only $a_k$ and $a_j$ exchange between $T$ and $T'$, it follows $a_j \in \{a_1, a_2\}$, resulting in a violation of Condition~\ref{condition2} for $a_j$ in $T'$ and hence $a_j \notin M_{T'}$.
	We can conclude $(M_{T'} \setminus M_T) \neq \{a_k, a_j\}$, and hence $m_{T'} \leq m_T + 1$.

	It remains to show that if $p_{T'} = p_T - 1$, it cannot be $m_{T'} = m_T + 1$, in order to prove Inequality~\ref{eq:distance_proof}.
	We assume $p_{T'} = p_T - 1$, hence $(a_k, a_j)$ is a transposition in $T$, meaning that $\rank(a_k)_T < \rank(a_j)_T$ and $\rank(a_k)_R > \rank(a_j)_R$.
	As $a_k$ and $a_j$ are the only leaves whose membership can change between $M_T$ and $M_{T'}$, it suffices to show that none of them can be in $M_{T'} \setminus M_T$.

	That $a_k$ is not in $M_{T'}$ follows from $\rank(a_j)_{T'} < \rank(a_k)_{T'}$ and $\rank(a_j)_R < \rank(a_k)_R$, and hence $a_k \notin M_{T'} \setminus M_T$.
	Moreover, if $a_j \in M_{T'}$, it follows $a_j \in M_{T'}$, which yields $a_j \notin M_{T'} \setminus M_T$, as explained in the following.
	If $a_j \in M_{T'}$, both conditions \ref{condition1} and \ref{condition2} are met by $a_j$ in $T'$.
	With $\rank(a_k)_T < \rank(a_j)_T$ and $\rank(a_k)_R > \rank(a_j)_R$ it immediately follows that these conditions are also met in $T$, and hence $a_k \notin M_{T'} \setminus M_T$.

	Concluding, it is $M_{T'} \setminus M_T = \emptyset$, and we can follow that if $p_{T'} = p_T - 1$, it is $m_{T'} < m_T + 1$, which concludes this proof.
\end{proof}

\begin{corollary}
	The distance between two caterpillar trees can be computed in $\O(n \log n)$ in $\rnni$.
	\label{cor:caterpillar_distance_rnni_nlogn}
\end{corollary}

\begin{proof}
	By \autoref{thm:caterpillar_distance_formula} the distance between two caterpillar trees is the number of transpositions between two sequences of length $n$ minus the variable $m_T$ as defined in \autoref{thm:caterpillar_distance_formula}.
	The value $m_T$ can be computed time linear in $n$ for any caterpillar tree $T$ by considering the leaves of the tree ordered according to increasing rank of their parents.
	The number of transpositions of a sequence of length $n$ (Kendall-tau distance) can be computed in time $\O(n \log n)$ \autocite{Knight1966-hx}.
	The worst-case running time for computing the distance between caterpillar trees in $\rnni$ is therefore $\O(n \log n)$.
\end{proof}

\begin{corollary}
	The distance between two caterpillar trees can be computed in $\O(m + n \log n)$ in $\dtt_m$.
	\label{cor:caterpillar_distance_dtt_m_nlogn}
\end{corollary}

\begin{proof}
	With \autoref{lemma:dtt_path_sum} we know that the distance between two caterpillar trees $T$ and $R$ in $\dtt_m$ is the sum of minimal $\rnni$ moves and the minimal number of length moves between $T$ and $R$.
	As we already saw in the proof of \autoref{lemma:dtt_path_sum}, the minimum number of length moves is $\sum_{i = n+1}^{m+2} |\rank(a_{i})_{T_c} - \rank(a_{i})_{R_c}|$.
	Furthermore, the minimum number of $\rnni$ moves is equivalent to the $\rnni$ distance between the trees $\hat T$ and $\hat R$ that result from $T$ and $R$ by ignoring times and only keeping ranks, respectively.
	Since the sum that gives the number of length moves can be computed in time linear in $m$ and the $\rnni$ distance between $\hat T$ and $\hat R$ in $\O(n \log n)$ (\autoref{cor:caterpillar_distance_rnni_nlogn}), the distance between $T$ and $R$ in $\dtt_m$ can be computed in $\O(m + n \log n)$.
\end{proof}

\subsection{Diameter and Radius}

\summary{Definition of Diameter.}
In this section we  investigate the \emph{diameter} of $\rnni$ and $\dtt_m$, which is the greatest distance between any pair of vertices (trees) in each of these graphs, respectively, i.e. $\max\limits_{\text{trees }T,R}d(T,R)$.
We establish the exact diameter for $\dtt_m$ and the diameter of $\rnni$ as a special case of it, improving the upper bound $n^2 - 3n - \frac{5}{8}$ for the diameter of $\rnni$ given by \textcite{Gavryushkin2018-ol}.


\begin{theorem}
	The diameter of $\dtt_m$ is $m(n-1) - \frac{n(n-1)}{2}$.
	\label{thm:dtt_diameter}
\end{theorem}

\begin{proof}
	Let $T$ and $R$ be two trees in $\dtt_m$ and $T_r$ and $R_r$ their ranked versions on $m+2$ leaves.
	In every iteration $i$ of $\findpath$ the maximum number of moves is $m-i$, as described following.
	Let $C$ be the cluster induced by the node of rank $i$ of $R$, and hence the cluster who's most recent common ancestor gets moved down in iteration $i$ of $\findpath$.
	The maximum rank of $(C)_T$ is $m$, as this is the rank of the root of the subtree containing all elements of $C$.
	And since the rank of the most recent common ancestor of $C$ decreases when running $\findpath$ until it reaches $i$, the maximum number of moves in iteration $i$ is $m-i$.
	Hence the sum of all moves needed over all iterations of $\findpath$ is
	\[\sum\limits_{i = 1}^{n-1} (m - i) = m(n-1) - \frac{n(n-1)}{2}.\]
	This formula is not only an upper bound of the diameter of $\dtt_m$, there are trees with this distance.
	An example of such trees is provided in \autoref{fig:cat_max_dist_dtt} where the path computed by $\findpath$ has length $m(n-1) - \frac{n(n-1)}{2}$.
	These trees have maximum distance from each other as the maximum number of moves $m-i$ is reached in each iteration $i = 1, \ldots, n$.
	\begin{figure}[ht]
		\includegraphics[width=0.65\textwidth]{cat_max_dist_dtt.eps}
		\caption{Trees with distance $m(n-1) - \frac{n(n-1)}{2}$}
		\label{fig:cat_max_dist_dtt}
	\end{figure}
\end{proof}

\todo{Mention that the running time of $\findpath$ follows from the diameter!}
Since the $\rnni$ graph is the graph $\dtt_{n-1}$, the diameter of $\rnni$ is a direct result of \autoref{thm:dtt_diameter}.

\begin{corollary}
	The diameter of $\rnni$ is $\frac{(n-1)(n-2)}{2}$.
	\label{cor:diameter_rnni}
\end{corollary}

\summary{Radius of $\rnni$ is equal to its diameter.}
The \emph{radius} of a graph is defined $\min\limits_{\text{tree } T}\max\limits_{\text{tree }R} d(T,R)$, where $d$ is a distance measure of the graph.
In other words, it is the minimum distance of any vertex in the graph to the vertex with maximum distance from it.
\todo{Radius of $\dtt_m$?}
In the following we see that the radius of $\rnni$ equals its diameter.
For proving this, we need the following lemma.

\begin{lemma}
	For every tree in $\rnni$ exists a caterpillar tree with distance $\frac{(n-1)(n-2)}{2}$ from it.
	\label{lemma:max_dist_tree_rnni}
\end{lemma}

\begin{proof}
	We prove this lemma by induction on the number of leaves $n$.
	The base case $n=3$ is trivial, as all three trees in this space are caterpillar trees with distance one from every other tree.
	For the induction step we consider an arbitrary tree $T$ with $n+1$ leaves.
	Let $x$ and $y$ be the leaved of $T$ that have the internal node of rank $1$ as parent in $T$, and let $T'$ be the tree on $n$ leaves resulting from deleting one of the leaves, say $x$, of $T$.
	By the induction hypothesis there is a caterpillar tree $R'$ with distance $\frac{(n-1)(n-2)}{2}$ to $T'$.
	Now consider the tree $R$ resulting from adding $x$ at the top of $R'$ such that the root of $R$ has $x$ and $R'$ as children.

	To compute a path from $R$ to $T$, in the first iteration of $\findpath$ the leaf $x$ moves down by $\nni$ moves until it reaches $y$.
	A further $\nni$ moves creates an internal node with children $x$ and $y$, which is then moved down by rank swaps as depicted in Figure~\ref{fig:max_dist_ctree}.
	Altogether, there are $n-1$ $\rnni$ moves needed to build the cluster $\{x,y\}$ and decrease the rank of the node inducing this cluster until it reaches rank one, as the rank of the parent of $x$ decreases by one within every move, starting at the root with rank $n$ and ending at the internal node of rank one.
	The tree at the end of this first iteration on $\fp(T,R)$ is identical to $R'$ when removing the leaf $x$ and suppressing its parent.
	Since the cluster $\{x,y\}$ is not considered again in $\findpath$, the remaining part of $\fp(T,R)$ contains the same moves as $\fp(T',R')$, and hence $|\fp(T,R)| = |\fp(T',R')| + n-1$.
	Therefore it is $d(T,R) = \frac{(n-1)(n-2)}{2} + n-1 = \frac{n(n-1)}{2}$, which proves the lemma.
	\begin{figure}[ht]
		\includegraphics[width=0.8\textwidth]{max_dist_ctree.eps}
		\caption{Initial $n - 1$ $\rnni$ moves of $\fp(R,T)$ as described in the proof of Lemma~\ref{lemma:max_dist_tree_rnni}.
		Removing the leaf $x$ and suppressing the non-root node of degree two from the tree on the right results in $R'$ as described in the lemma.}
		\label{fig:max_dist_ctree}
	\end{figure}
\end{proof}

\begin{corollary}
	The radius of the $\rnni$ graph equals its diameter $\frac{(n-1)(n-2)}{2}$.
\end{corollary}

Unlike in $\rnni$, the radius of $\dtt_m$ does not equal its diameter.
A counterexample is given by the tree depicted in \autoref{fig:dtt_radius_counterexample} on three leaves in $dtt_4$.There is no tree in $\dtt_4$ that has distance $m(n-1) - \frac{n(n-1)}{2}$, which is the diameter of $\dtt_m$, from that tree.

\begin{figure}[ht]
	\includegraphics[width=0.15\textwidth]{dtt_radius_counterexample.eps}
	\caption{Tree in $\dtt_4$ on three leaves for which there is not tree with distance $5 = m(n-1) - \frac{n(n-1)}{2}$ (diameter) from it}
	\label{fig:dtt_radius_counterexample}
\end{figure}


\section{$\rnni(\rho)$}

\todo{How can we connect $\rnni(\rho)$ to $\dtt_m$?}

\subsection{Caterpillar Trees}

\summary{The set of caterpillar trees is convex in $\rnni(\rho)$ for $\rho > 1$.}
\begin{corollary}
	The set of caterpillar trees is convex in $\rnni(\rho)$ if and ony if $\rho \geq 1$.
\end{corollary}

\begin{proof}
	We start with proving that if the set of caterpillar trees is convex, then it is $\rho \geq 1$.
	More specifically, we show that if $\rho < 1$, then the set of caterpillar trees is not convex, from which the previous statement follows.
	Therefore we consider the following example of trees with four leaves.
	Let
	\begin{align*}
		T &= [\{1,2\},\{1,2,3\},\{1,2,3,4\}]\text{ and }\\
		R &= [\{3,4\},\{1,3,4\},\{1,2,3,4\}].
	\end{align*}
	The shortest among all caterpillar paths between $T$ and $R$ has length three and is depicted at the bottom of Figure~\ref{fig:caterpillar_non_convex}.
	However, there is a path that is shorter than this path and has length $2 + \rho$, which is smaller than three for $\rho < 1$.
	This path is depicted at the top of Figure~\ref{fig:caterpillar_non_convex}.
	Hence, the set of caterpillar trees is not convex if $\rho < 1$.
	\begin{figure}[ht]
		\includegraphics[width=0.5\textwidth]{caterpillar_non_convex.eps}
		\caption{A shortest caterpillar path between caterpillar trees $T$ and $R$ at the bottom and a path consisting of non-caterpillar trees at the top.
		The path at the top is shorter than the one at the bottom for all $\rho<1$.}
		\label{fig:caterpillar_non_convex}
	\end{figure}

	It remains to prove that if $\rho \geq 1$, then the set of caterpillar trees is convex.
	With Theorem~\ref{thm:caterpillar_convex_rnni} we know that this is true for $\rho = 1$.
	Moreover, the statement for $\rho > 1$ follows from the same theorem as described in the following, where we assume that $\rho > 1$.
	All paths between any two trees in $\rnni(\rho)$ are longer or have equal length to the path containing the same moves in $\rnni$, as the weights of the moves in $\rnni(\rho)$ are greater or equal to the weights of the same moves in $\rnni$.
	Specifically, the only paths that have the same length in $\rnni$ and $\rnni(\rho)$ are paths that contain only $\nni$ moves.
	It follows that caterpillar paths of $\rnni$ have the same length in $\rnni(\rho)$, while other paths might be longer in $\rnni(\rho)$, but cannot be shorter than the same path in $\rnni$.s
	And as there is a shortest caterpillar path between all caterpillar trees in $\rnni$, this path is shortest path in $\rnni(\rho)$ as well.
	This proves that the set of caterpillar trees is convex in $\rnni(\rho)$ for $\rho \geq 1$, which completes the proof.
\end{proof}

\subsection{Diameter and Radius}

\summary{Diameter for $\rnni(0)$ follows from $\nni$}
Not only for $\rnni$, but also for $\rnni(0)$, we know the diameter from previous results.
As rank moves in $\rnni(0)$ weigh zero, the distance between two trees in this space is the same as the $\nni$ distance between these trees when ignoring ranks.
Therefore, these graphs have the same diameter.

\begin{proposition}
	The diameter of $\rnni(0)$ is $\Theta(n \log(n))$.
	\label{prop:diameter_nni}
\end{proposition}

\begin{proof}
	This follows from the diameter of the $\nni$ graph, which is known \autocite{Semple2003-nj} to be $\Theta(n \log(n))$.
\end{proof}

\summary{Results for $\rnni$ and $\rnni(0)$ give us bounds for the diameters of all spaces with $0 < \rho < 1$.}
With the previous results in Corollary~\ref{cor:diameter_rnni} and Proposition~\ref{prop:diameter_nni} we can infer bounds for diameters of spaces $\rnni(\rho)$ with $0 < \rho < 1$.
A path in $\rnni(\rho)$ between two trees corresponds to paths in $\rnni(0)$ and $\rnni(1)$ that contain the same moves, but have different total length, due to the different weighing of rank moves.
Therefore, the length of such a path is bounded from below by the length of the corresponding path in $\rnni(0)$ and from above by the corresponding path in $\rnni(1)$.
With Corollary~\ref{cor:diameter_rnni} and Proposition~\ref{prop:diameter_nni} it follows that the diameter of $\rnni(\rho)$ with $\rho < 1$ is bounded from below by $\Theta(n \log(n))$ and from above by $\frac{(n-1)(n-2)}{2}$.

\summary{Diameter of $\rnni(\rho)$ for $\rho > 1$.}
So far $\rnni(\rho)$ for $0 \leq \rho \leq 1$ has been the centre of our investigation of diameters.
We now continue by considering spaces $\rnni(\rho)$ for $\rho > 1$, where rank moves are more expensive than $\nni$ moves.
Specifically, we give an upper bound for the diameter of $\rnni(\infty)$ from which we can follow that all spaces $\rnni(\rho)$ have a diameter less or equal to this bound.
\todo{Refer to \autoref{lemma:nni_path_to_caterpillar} or move the lemma here}
Before this, however, we need to observe that for $\rnni(\infty)$ every pair of trees is connected by a path consisting of $\nni$ moves only.

\summary{Every tree in $\rnni$ can be connected to a caterpillar tree by $\nni$ moves only, hence there is a path between very pair of trees that consists of $\nni$ moves only}
\begin{lemma}
	In $\rnni$ every tree is connected to a caterpillar tree by a path that consists of $\nni$ moves only.
	\label{lemma:nni_path_to_caterpillar}
\end{lemma}

\begin{proof}
	We prove this lemma for a given tree $T$ by induction on the number $i$ of rank intervals of $T$.
	In the base case $k = 0$ the tree $T$ is a caterpillar tree and the statement is true.
	For the induction step we assume that $T$ has $i+1$ rank intervals and all trees with less than $i+1$ rank intervals are connected to a caterpillar trees through a sequence of $\nni$ moves.
	We now construct a series of $\nni$ moves that, starting at $T$, ends in a tree that has less than $i+1$ rank intervals.
	Let the node of rank $k+1$ in $T$ be the highest ranked node incident to a rank interval.
	This means that the interval given by nodes of rank $k$ and $k+1$ is a rank interval and all intervals above $(T)_{k+1}$ are edges.
	Let $(T)_l$ be the parent of $(T)_k$.
	Hence $l > k+1$, and $[(T)_{l-1}, (T)_{l}]$ is an edge.
	On this edge an $\nni$ move can be performed that results in a tree $T'$ in which the rank of the parent of $(T')_k$ is $l-1$, as depicted in Figure~\ref{fig:nni_path_caterpillar}.
	In the tree $R$ resulting from iteratively repeating this until $l = k+1$ the parent $(R)_k$ has rank $k+1$.
	Hence the rank interval bounded by nodes of rank $k$ and $k+1$ in $T$ turned into an edge while all intervals above $k+1$ remain edges in $R$.
	As $R$ has one rank interval less than the $i+1$ rank intervals of $T$, the induction hypothesis can be applied to $R$.
	This gives a sequence from $T$ to a caterpillar via $R$ that consists of $\nni$ moves only.
	\begin{figure}[ht]
		\includegraphics[width=0.8\textwidth]{nni_path_caterpillar.eps}
		\caption{Example of a tree $T$ with two rank intervals and a sequence of $\nni$ moves that results in a tree $R$ with one rank interval as described in the proof of Lemma~\ref{lemma:nni_path_to_caterpillar}.}
		\label{fig:nni_path_caterpillar}
	\end{figure}
\end{proof}

\begin{corollary}
	The diameter of $\rnni(\infty)$ is less or equal to $3 \frac{(n-1)(n-2)}{2}$.
\end{corollary}

\begin{proof}
	Let $T$ and $R$ be two trees in $\rnni(\infty)$.
	With Lemma~\ref{lemma:nni_path_to_caterpillar} we know that any tree can be connected to a caterpillar tree by a sequence of $\nni$ moves.
	Moreover, the proof of the lemma implicitly proposes an algorithm to convert a tree into a caterpillar tree by removing rank intervals by a top-down approach.
	We show that the paths from a tree to a caterpillar tree that are given by this algorithm have at most length $\frac{(n-1)(n-1)}{2}$.
	Since we also know that the set of caterpillar trees is convex in $\rnni$ (Theorem~\ref{thm:caterpillar_convex_rnni}), and hence the maximum distance between caterpillar trees is bounded by the diameter $\frac{(n-1)(n-2)}{2}$ of $\rnni$ (Corollary~\ref{cor:diameter_rnni}), this corollary follows.

	For finding the maximum length of a path computed by the algorithm suggested in the proof of Lemma~\ref{lemma:nni_path_to_caterpillar}, we consider every iteration (induction step).
	In each of these, at least one rank interval turns into an edge.
	The number of $\nni$ moves needed for this depends on the rank of the upper node bounding the rank interval.
	If we assume the worst case, that is, every interval except for the edge $[(T)_{n-1},(T)_{n-2}]$ is a rank interval, then there are $i$ $\nni$ moves needed in iteration $i$.
	Since there are $n-2$ iterations, it follows that at most $\frac{(n-1)(n-2)}{2}$ $\nni$ moves are needed to get from an arbitrary tree to a caterpillar tree.
	\todo{I suspect writing the algorithm down properly and using it to prove Lemma~\ref{lemma:nni_path_to_caterpillar} and this corollary might be easier than this. This explanation of the 'implicitly' defined algorithm is not sufficient.}
\end{proof}

\summary{Radius of $\rnni(\rho)$ for other values of $\rho$.}

\subsection{Cluster Property}

\summary{$\rnni(0)$ does not have cluster property.}
\begin{proposition}
	$\rnni(0)$ does not have the cluster property.
\end{proposition}

\summary{Cluster Property of $\rnni(\rho)$ for $\rho \neq 0, 1$?}


%TODO: Leave this as a section or do we want a section (not just subsection) for DtT?
\section{Generalisation}

\summary{All (?) results from $\rnni$ transfer to discrete time-trees.}

\summary{How partition lattices correspond to $\rnni$.}

\summary{Implementation of FP}

\todo{We should mention that in an implementatino of $\findpath$ on discrete time-trees we would not add leaves but implement length moves, to save memory}

\end{document}